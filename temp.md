## 并发问题
* 锁相关
    - MySQL中：行锁、表锁（只要是锁就有开销，粒度越细开销越大）
    - **意向锁**（IX, IS）：为了避免过多的检查行级锁而设计，当一个线程需要加X时，必须先获取IX（IX加在表级）
    - **封锁协议**：总共三级封锁协议
        - 一级：写要加X锁；
        - 二级：读要加S锁，读完释放，可避免RC；
        - 三级：读要加S锁，事务提交释放，可避免RR；
* 除了加锁还有哪些方法解决并发冲突
    - MVCC
      - 针对的是RC和RR两种级别
      - 多版本指的是多个版本的快照，快照存储在undo日志中，该日志通过回滚指针ROLL_PTR把一个数据行的所有快照连接起来
      - 快照读、当前读
      - 注意MVCC不能解决幻读，因此需要使用next-key lock来解决
    - copy on write：写时复制，本质就是读写分离

## java 中的并发
* 锁
  - synchronized：JVM实现（JVM确保锁释放，不用担心死锁）、不可中断
  - ReentrantLock：JDK实现、等待可中断、可以绑定多个Condition对象
* java 中的线程
  - 线程间的协作
    - join()：A调用B的join()方法，意为A希望B参与进来，因此是A等待B执行完
  - wait()和sleep()和await()
    - wait()是Object的方法，wait()会释放锁
    - sleep()是Thread的静态方法，sleep()不会释放锁
    - await()是juc提供的，await()可以指定等待的条件，更灵活
  - JUC（核心是AQS:AbstractQueuedSynchronizer抽象队列式同步器）
    - CountdownLatch：维护一个计数器
    - CyclicBarrier：通过调用reset()可以循环使用，因此才叫循环屏障
    - Semaphore：用于控制对互斥资源的访问线程数
  - JUC中的方便组件
    - FutureTask：实现了RunnableFuture接口，既能当成一个任务执行，也能返回值
    - BlockingQueue：提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。用作**生产者消费者**的访问容器再合适不过。
    - ForkJoin：用于并行计算，和MapReduce类似，都是把大的计算任务拆分成多个小任务并行计算（ForkJoinPool实现了工作窃取算法，每个线程维护一个双端队列，存储需要执行的任务）
  - **AQS**
    - 抽象队列化同步器：
      - JUC中的每个组件都内部实现了AQS，使用了模板模式，类似集合中的Iterator
      - 基于改进的CLH队列（双向指针）和资源的state来管理线程
      - 会封装线程为Node，*Node内部总共有4个指针，head、tail、prev、next*
    - 工作原理：
      - JUC组件实现Sync继承AQS，实现tryAcquire()等方法供AQS调用
      - 入口是AQS.acquire()方法
      - 底层基础是CAS，LockSupport等（LockSupport.park()类似wait()）
* 线程安全
  - 不可变：不可变当然安全，包括final基本类型、String、枚举、Number部分子类
  - 互斥同步：synchronized和ReentrantLock（悲观策略）
  - 非阻塞同步：解决**互斥同步的线程阻塞与唤醒的性能问题**，方法为不断重试（乐观策略）
    - CAS：需要3个操作数，分别为：内存地址V、旧的预期值A、新值B；操作时，只有 当V中的值==A，才将V中的值更新为B
    - ABA：CAS无法避免ABA问题，可以通过加版本号解决（AtomicStampedReference类）
* 锁优化（主要指JVM对synchronized的优化）
  - 自旋锁：互斥同步进入阻塞状态开销大，因此使用忙循环避免进入此状态（占用cpu时间）
  - 锁消除：检测不可能竞争的锁，进行消除（利用了**逃逸分析**来支持）
  - 锁粗化：调整加锁的范围
  - 轻量级锁：先使用CAS操作，不行再上锁
  - 偏向锁：偏心第一个获取锁的线程，此线程此后再获取该锁就不再进行同步操作，甚至连CAS也不用

## Java虚拟机
* 运行时数据区
  - 虚拟机栈（线程栈）
    - 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.5+ 默认为 1M
      - 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
      - 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常；
  - 方法区（内部包括运行时常量池）
    - *用于存放已被加载的类信息、常量、静态变量、即时编译后代码等数据*
    - 和堆一样可动态扩展，扩容失败会抛出OOM
    - **方法区是JVM的一个规范**，永久代与元空间都是其一种实现方式，JDK1.8之后，使用元空间实现（元空间存储类的元信息，静态变量和常量池等放入堆中）
* GC
  - 如何判断可GC
    - 引用计数：存在循环引用的情况，JVM不用
    - **可达性分析**：从GC Root出发 分析可达性，Root如下
      - 虚拟机栈中局部变量表引用的对象
      - 本地方法栈中JNI中引用的对象
      - 方法区中类静态属性引用的对象
      - 方法区中常量引用的对象
  - 强软弱虚如何影响GC
    - ThreadLocalMap中的key为啥使用弱引用：key值为ThreadLocal对象本身，会受到两个方向的引用，1是从栈中引用的（码农操作），2是ThreadLocalMap的key值的引用（非码农操作），*为了ThreadLocal的生命周期能被码农控制*，2方向的引用使用弱引用
  - GC算法
    - 标记-清除
    - 标记-整理
    - 复制-整理
    - 分代收集（主流）
      - 新生代：复制-整理
      - 老年代：标记-清除或标记-整理
  - GC实现
    - CMS：并发标记清除，周期包括三次标记一次清除，清除不会STW
    - G1：可以直接对新生代和老年代一起回收，G1是**棋盘状划分内存**，新生代和老年代不再物理隔离
* 类加载
  - 类加载器及对应加载的路径：
    - Bootstrap ClassLoader -> <JAVA_HOME>/lib
    - Extention ClassLoader -> <JAVA_HOME>/lib/ext
    - Application ClassLoader -> ClassPath

## Java容器
* List
  - ArrayList：使用了modCount（结构发生变化的次数，设置元素的值不算结构变化）来实现**Fail-Fast**
  - 线程安全：可以使用Collections.synchronizedList()（底层就是使用了同步代码块包裹集合操作，mutex设置为原集合对象）
  - CopyOnWriteArrayList：**写时复制**的ArrayList，写操作在一个复制出来的数组上进行，读写分离，大大提高读的性能，适用于读多写少的场景
* Map
  - HashMap：底层是桶链结构（jdk1.8开始，一个桶里链表长度>=8时会将链表转换为**红黑树**）
  - ConcurrentHashMap：使用了**分段锁（segment）**，加在桶上，支持的并发数就是segment的个数
  - ConcurrentCache：Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能（内部维护了两个map，一个是eden区，一个是longterm区，后者的实现就是WeakHashMap，利用虚拟机回收不常用的对象）

## Java IO
* Java 的 I/O 大概可以分成以下几类：
  - 磁盘操作：File
  - 字节操作：InputStream 和 OutputStream
  - 字符操作：Reader 和 Writer
  - 对象操作：Serializable
  - 网络操作：Socket
  - 新的输入/输出：NIO
* 编码与解码：编码就是把字符转换为字节，而解码是把字节重新组合成字符。
  - 如果编码和解码过程使用不同的编码方式那么就出现了乱码
    - GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节
    - UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节
    - UTF-16be 编码中，中文字符和英文字符都占 2 个字节
* 网络操作
  - InetAddress：用于表示网络上的硬件资源，即 IP 地址
  - URL：统一资源定位符
  - Sockets：使用 TCP 协议实现网络通信
  - Datagram：使用 UDP 协议实现网络通信
* NIO
  - I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据
  - 组成（CBS）
    - 通道：对原I/O中流的模拟，不同之处在于它是双向的
    - 缓冲：读写必须经过缓冲，flip()方法用于调整position和limit指针
    - 选择器：轮询监听事件的方式处理channel上的I/O事件（一个线程处理多个事件，因为创建和切换线程的开销很大）

## 系统设计
* 系统设计基础
  - 性能：吞吐量、并发用户数
    - 性能优化方式：集群、缓存、异步
  - 伸缩性：加机器的能力，系统无状态的情况下可以很轻松的通过负载均衡横向扩容
  - 扩展性：加功能的能力，要求系统低耦合
  - 可用性：
    - 保证可用性的方式：冗余、监控、服务降级（关闭边缘功能保核心）
  - 安全性
* 分布式
  - CAP理论：
    - 为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；
    - 为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。
  - ACID要求强一致，BASE只要求最终一致，实际使用时会结合在一起
  - 算法（主要思路都是Leader接收，Follower同步，在这种思路中，**数据的更新**都包括两个阶段，即 **1写入日志、2提交修改**）：
    - Paxos算法：用于达成共识性，即多个节点产生的值，该算法能保证只选出唯一一个值
    - Raft算法：也是分布式一致性协议，主要用来竞选主节点
* redis 分布式锁
  - 场景：解决商品超卖的现象
  - 理论 **Redlock**，Java的实现 **Redisson**
    - redisson非常简答的lock与unlock即可，顶多unlock的时候判断一下heldByCurrentThread，避免非法监控器状态异常
  - redis 9种淘汰策略
    - 基础就4种：LRU LFU TTL Random；再分两类：allKey和volatile；再加1种：不淘汰（默认是这种）
* 集群
  - 主要就是负载去哪的问题，分两个阶段：1根据算法找节点，2进行转发
  - 负载均衡算法6种
    - 轮询RR（一般、加权）、最少连接LC（一般、加权）、随机、源地址hash(ip_hash)
  - 转发实现
    - http重定向
    - DNS域名解析
    - 反向代理服务器
* 攻击技术
  - 跨站脚本攻击 XSS：核心是将代码注入到用户浏览的网页上，包括HTML和JavaScript
  - 跨站请求伪造 CSRF：核心是欺骗用户的浏览器去访问一个曾经认证过的网站并执行一些操作
  - SQL注入攻击：
  - 拒绝服务攻击 DoS DDoS：拒绝服务攻击、分布式拒绝服务攻击（两台以上的攻击源）

## 缓存
* 缓存位置（8个层级）
  - 浏览器：当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。
  - ISP：网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。
  - 反向代理：反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。
  - 本地缓存：使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。
  - 分布式缓存：使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。
  - 数据库缓存：MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。
  - Java 内部的缓存：Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。
  - CPU 多级缓存：CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。
* 缓存问题
  - 缓存穿透：缓存一个空数据解决
  - 缓存雪崩：使用分布式缓存解决，每个节点只缓存一部分数据
  - 缓存一致性：保证缓存一致性需要很大的代价，有时可以允许一部分脏缓存数据
  - 缓存“无底洞”
* 数据分布
  - 哈希分布：缺点是节点数量变化时，几乎所有的数据都要重新分布，大量迁移数据；解决办法是，**一致性哈希（DHT）**，原理是将哈希空间看作一个环。
  - 顺序分布：优点是能保持数据原有的顺序，能精确控制每个节点的数据量

## 消息队列
* 消息模型
  - 点对点
  - 发布订阅
* 使用场景
  - 异步处理
  - 流量削峰
  - 应用解耦
* 可靠性
  - 发送端的可靠性：发送端发完消息后一定能将信息送到消息队列中
    - 利用本地事务，本地数据库中建一张消息表，事务提交成功后将消息表的数据转移到消息队列中
  - 接收端的可靠性：接收端能从消息队列成功消费一次消息
    - 保证接收端的处理逻辑幂等
    - 消息具有唯一编号，用一张日志表来记录已消费信息